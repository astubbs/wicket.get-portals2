<wicket:extend>
<b>Commons Attribute and Bean Proxy Approach</b><br/>
This approach allows users to quickly and easily inject any page, panel, or component with bean proxies. Any page or panel that wishes to be injected has to extend either InjectableWebPage or InjectablePanel. Any component that wishes to be injected can do so by calling InjectorHolder.getInjector().inject(this) from its constructor.
Interesting classes:<br/>
<ul>
	<li>CAttrApplication - serves as a link between wicket and spring ApplicationContext, also sets up an injector object that will be used to inject components annotated using commons attributes</li>
	<li>BasePage - extends InjectableWebPage instead of WebPage to allow subclasses to be injected automatically</li>
	<li>CommonsAttributePage - contains an annotated field whose value will be initialized with a proxy by the injector</li>
</ul>
<table wicket:id="contacts" cellspacing="0" cellpadding="2" class="grid"></table>
<br/>
Below is comparison of CommonsAttributePage and ProxyPage. Notice how much cleaner the dependency lookup is in the CommonsAttributePage (in fact the lookup itself is hidden, only an annotated field is present).
<br/>
<table cellspacing="0" cellpadding="2">
<tr>
	<td style="width:50%; vertical-align:top; border-right: 1px solid gray;">
<pre>
public class CommonsAttributePage extends ContactsDisplayPage {

	/**
	 * @@wicket.spring.injection.cattr.SpringBean
	 */
	private ContactDao dao;

	public CommonsAttributePage() {

	}

	protected SortableDataProvider getDataProvider() {
		return new ProxyDataProvider(dao);
	}
}
</pre>
	</td>
	<td style="width:50%; vertical-align:top;">
<pre>
public class ProxyPage extends ContactsDisplayPage {
	public ProxyPage() {

	}

	private ContactDao getContactDao() {
		return ((ExampleApplication) Application.get()).getContactDaoProxy();
	}

	protected SortableDataProvider getDataProvider() {
		return new ProxyDataProvider(getContactDao());
	}
}
</pre>
	</td>
</tr>
</table>

</wicket:extend>
