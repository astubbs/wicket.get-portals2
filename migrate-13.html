<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
  <HEAD>
    <LINK type="text/css" rel="stylesheet" href="resources/space.css">
    <STYLE type="text/css">
      .footer {
        background-image:      url('http://cwiki.apache.org/confluence/images/border/border_bottom.gif');
        background-repeat:     repeat-x;
        background-position:   left top;
        padding-top:           4px;
        color:                 #666;
      }
    </STYLE>
    <SCRIPT type="text/javascript" language="javascript">
      var hide = null;
      var show = null;
      var children = null;

      function init() {
        /* Search form initialization */
        var form = document.forms['search'];
        if (form != null) {
          form.elements['domains'].value = location.hostname;
          form.elements['sitesearch'].value = location.hostname;
        }

        /* Children initialization */
        hide = document.getElementById('hide');
        show = document.getElementById('show');
        children = document.all != null ?
                   document.all['children'] :
                   document.getElementById('children');
        if (children != null) {
          children.style.display = 'none';
          show.style.display = 'inline';
          hide.style.display = 'none';
        }
      }

      function showChildren() {
        children.style.display = 'block';
        show.style.display = 'none';
        hide.style.display = 'inline';
      }

      function hideChildren() {
        children.style.display = 'none';
        show.style.display = 'inline';
        hide.style.display = 'none';
      }
    </SCRIPT>
    <TITLE>Migrate-1.3</TITLE>
  <META http-equiv="Content-Type" content="text/html;charset=UTF-8"></HEAD>
  <BODY onload="init()">

    <DIV id="PageContent">

      <DIV class="pagecontent">
        <DIV class="wiki-content">
          <H1><A name="Migrate-1.3-MigratingtoWicket1.3"></A>Migrating to Wicket 1.3</H1>

<DIV class="panel" style="border-style: solid; "><DIV class="panelHeader" style="border-bottom-style: solid; "><B>Table of contents</B></DIV><DIV class="panelContent">
<DIV>
<UL>
  <LI><A href="#Migrate-1.3-Packagerename">Package rename</A></LI>
  <LI><A href="#Migrate-1.3-FilterinsteadofaServlet">Filter instead of a Servlet</A></LI>
  <LI><A href="#Migrate-1.3-APIchanges">API changes</A>
<UL>
  <LI><A href="#Migrate-1.3-IModelchange">IModel change</A></LI>
  <LI><A href="#Migrate-1.3-Component.onAttach%252FonBeforeRender%252FonAfterRenderchanges.">Component.onAttach/onBeforeRender/onAfterRender changes.</A></LI>
  <LI><A href="#Migrate-1.3-Converters">Converters</A></LI>
  <LI><A href="#Migrate-1.3-ValidationChanges">Validation Changes</A></LI>
  <LI><A href="#Migrate-1.3-WicketTesterandMockWebApplication">WicketTester and MockWebApplication</A></LI>
  <LI><A href="#Migrate-1.3-Mounts">Mounts</A></LI>
  <LI><A href="#Migrate-1.3-RequestCycle%252CIRequestCycleFactory%252CSession%252CISessionFactory%252CIPageMapandPageMapchanges">RequestCycle, IRequestCycleFactory, Session, ISessionFactory, IPageMap and PageMap changes</A></LI>
  <LI><A href="#Migrate-1.3-CustomSessions">Custom Sessions</A></LI>
  <LI><A href="#Migrate-1.3-Repeaters">Repeaters</A></LI>
  <LI><A href="#Migrate-1.3-TextTemplate">TextTemplate</A></LI>
  <LI><A href="#Migrate-1.3-DatePicker">DatePicker</A></LI>
  <LI><A href="#Migrate-1.3-PortletsJSR168">Portlets JSR-168</A></LI>
  <LI><A href="#Migrate-1.3-ISessionStore">ISessionStore</A></LI>
  <LI><A href="#Migrate-1.3-Button">Button</A></LI>
  <LI><A href="#Migrate-1.3-IHeaderContributor">IHeaderContributor</A></LI>
  <LI><A href="#Migrate-1.3-IBehavior">IBehavior</A></LI>
  <LI><A href="#Migrate-1.3-ReplacementforgetBodyContainer">Replacement for getBodyContainer</A></LI>
  <LI><A href="#Migrate-1.3-FormComponent.IVisitor">FormComponent.IVisitor</A></LI>
  <LI><A href="#Migrate-1.3-ClientProperties">ClientProperties</A></LI>
  <LI><A href="#Migrate-1.3-Applicationsettings">Application settings</A></LI>
  <LI><A href="#Migrate-1.3-Customresourceloading">Custom resource loading</A></LI>
  <LI><A href="#Migrate-1.3-Treecomponents">Tree components</A></LI>
  <LI><A href="#Migrate-1.3-Testserializationsettingremoved">Test serialization setting removed</A></LI>
  <LI><A href="#Migrate-1.3-PalettecomponentinwicketextensionsnowhasdefaultCSS.">Palette component in wicket-extensions now has default CSS.</A></LI>
  <LI><A href="#Migrate-1.3-IRequestCycleProcessorgotsimplified">IRequestCycleProcessor got simplified</A></LI>
  <LI><A href="#Migrate-1.3-RemovedIPageSettings%2523maxPageVersions">Removed IPageSettings#maxPageVersions</A></LI>
  <LI><A href="#Migrate-1.3-SimplifiedHeaderContributor">Simplified HeaderContributor</A></LI>
  <LI><A href="#Migrate-1.3-Removedfeedbackmessagesfrompage">Removed feedback messages from page</A></LI>
  <LI><A href="#Migrate-1.3-Slightchangeinthehandlingofmultivaluedwidgets">Slight change in the handling of multivalued widgets</A></LI>
  <LI><A href="#Migrate-1.3-MadeiteasiertoaddIMarkupFiltertoMarkupParser">Made it easier to add IMarkupFilter to MarkupParser</A></LI>
  <LI><A href="#Migrate-1.3-LoggingAPIChange">Logging API Change</A></LI>
  <LI><A href="#Migrate-1.3-Application%2523configure%2528%2529DEPLOYMENT%252FDEVELOPMENTchanges">Application#configure() DEPLOYMENT/DEVELOPMENT changes</A></LI>
  <LI><A href="#Migrate-1.3-HtmlBodyContainer%253Cbody%253Egone">HtmlBodyContainer &lt;body&gt; gone</A></LI>
  <LI><A href="#Migrate-1.3-PasswordTextFieldnolongersupportscookiesbydefault">PasswordTextField no longer supports cookies by default</A></LI>
</UL></LI>
  <LI><A href="#Migrate-1.3-NewFeatures">New Features</A>
<UL>
  <LI><A href="#Migrate-1.3-wicket%253Aenclosuretag">wicket:enclosure tag</A></LI>
  <LI><A href="#Migrate-1.3-Reloadingclassloader">Reloading class loader</A></LI>
  <LI><A href="#Migrate-1.3-RelativeURLs">Relative URLs</A></LI>
</UL></LI>
</UL></DIV>
</DIV></DIV>

<H3><A name="Migrate-1.3-Packagerename"></A>Package rename</H3>

<P>Due to Wicket incubating at Apache, we applied a package rename for all core projects. Instead of wicket.&#42; we now use org.apache.wicket.*. The <SPAN class="nobr"><A href="http://wicket.sourceforge.net/" title="Visit page outside Confluence" rel="nofollow">http://wicket.sourceforge.net<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN> namescape declarations should be changed to <SPAN class="nobr"><A href="http://wicket.apache.org/" title="Visit page outside Confluence" rel="nofollow">http://wicket.apache.org<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN>.</P>

<H3><A name="Migrate-1.3-FilterinsteadofaServlet"></A>Filter instead of a Servlet</H3>

<P>The recommended set-up for Wicket now uses a servlet-api Filter, not a servlet-api Servlet (although a Servlet is still provided for use in environments that do not support a Filter).</P>

<P>Replace code like this (in subclasses of WebApplication):</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">ServletContext sc = getWicketServlet().getServletContext();</PRE>
</DIV></DIV>
<P>with</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">ServletContext sc = getServletContext();</PRE>
</DIV></DIV>
<P>and</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">wicket.protocol.http.IWebApplicationFactory#createApplication(wicket.protocol.http.WicketServlet)</PRE>
</DIV></DIV>
<P>is replaced by</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">wicket.protocol.http.IWebApplicationFactory#createApplication(wicket.protocol.http.WicketFilter)</PRE>
</DIV></DIV>
<P>You can get the servlet context from a filter like this:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">filter.getFilterConfig().getServletContext()</PRE>
</DIV></DIV>
<P>The main advantage of working with a filter instead of a servlet is that it is easier to pass through resources, and map your application to the root.</P>

<P>Here's an example of how to configure your application now with a filter in web.xml:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-xml"><SPAN class="code-tag">&lt;?xml version=<SPAN class="code-quote">&quot;1.0&quot;</SPAN> encoding=<SPAN class="code-quote">&quot;UTF-8&quot;</SPAN>?&gt;</SPAN>
&lt;!DOCTYPE web-app
      PUBLIC <SPAN class="code-quote">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</SPAN>
      <SPAN class="code-quote">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</SPAN>&gt;

<SPAN class="code-tag">&lt;web-app&gt;</SPAN>
  <SPAN class="code-tag">&lt;filter&gt;</SPAN>
    <SPAN class="code-tag">&lt;filter-name&gt;</SPAN>MyApplication<SPAN class="code-tag">&lt;/filter-name&gt;</SPAN>
    <SPAN class="code-tag">&lt;filter-class&gt;</SPAN>org.apache.wicket.protocol.http.WicketFilter<SPAN class="code-tag">&lt;/filter-class&gt;</SPAN>
    <SPAN class="code-tag">&lt;init-param&gt;</SPAN>
      <SPAN class="code-tag">&lt;param-name&gt;</SPAN>applicationClassName<SPAN class="code-tag">&lt;/param-name&gt;</SPAN>
      <SPAN class="code-tag">&lt;param-value&gt;</SPAN>com.myapp.MyApplication<SPAN class="code-tag">&lt;/param-value&gt;</SPAN>
    <SPAN class="code-tag">&lt;/init-param&gt;</SPAN>
  <SPAN class="code-tag">&lt;/filter&gt;</SPAN>

  <SPAN class="code-tag">&lt;filter-mapping&gt;</SPAN>
    <SPAN class="code-tag">&lt;filter-name&gt;</SPAN>MyApplication<SPAN class="code-tag">&lt;/filter-name&gt;</SPAN>
    <SPAN class="code-tag">&lt;url-pattern&gt;</SPAN>/app/*<SPAN class="code-tag">&lt;/url-pattern&gt;</SPAN>
  <SPAN class="code-tag">&lt;/filter-mapping&gt;</SPAN>
<SPAN class="code-tag">&lt;/web-app&gt;</SPAN></PRE>
</DIV></DIV>

<H3><A name="Migrate-1.3-APIchanges"></A>API changes</H3>


<H4><A name="Migrate-1.3-IModelchange"></A>IModel change</H4>

<P>IModel#getObject(Component) is replaced by IModel#getObject() and<BR>
IModel#setObject(Component, Object) is replaced by IModel#setObject(Object)</P>

<P>Here are some regex replacement that are helpful:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">s/<SPAN class="code-keyword">public</SPAN>\s+<SPAN class="code-object">Object</SPAN>\s+getObject\s*\(\s*(<SPAN class="code-keyword">final</SPAN>)*\s*(wicket.)?Component\s+\w+\s*\)/<SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">Object</SPAN> getObject()</PRE>
</DIV></DIV>
<P>and</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">s/<SPAN class="code-keyword">public</SPAN>\s+void\s+setObject\s*\(\s*(<SPAN class="code-keyword">final</SPAN>)*\s*(wicket.)?Component\s+\w+,\s*(<SPAN class="code-keyword">final</SPAN>)*\s*<SPAN class="code-object">Object</SPAN>\s+(\w+)\s*\)/<SPAN class="code-keyword">public</SPAN> void setObject(<SPAN class="code-object">Object</SPAN> \2)</PRE>
</DIV></DIV>
<P>You're probably best of doing the calls to get/setObject you did on models yourself manually.</P>

<P>Some miscellaneous abstract model classes have been removed as they did not provide much value. Here is a simple migration mapping if you extended one of the removed classes in your code:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">AbstractModel-&gt;Model
AbstractReadOnlyDetachableModel-&gt;LoadableDetachableModel (or other detachable models that don't need to have a setObject method)</PRE>
</DIV></DIV>
<P>if you do need the Component in the model (see below the IAssignementAwareModel) then there is a quick model</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">ComponentModel</PRE>
</DIV></DIV>
<P> that is pretty<BR>
much a drop in replacement for the current model implementation you have. If that model was a DetacheableModel then you can use the</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">ComponentDetachableModel</PRE>
</DIV></DIV>
<P>as a replacement. Then onAttach &#45;&gt; attach, onDetach &#45;&gt; detach, onSetObject is just setObject and onGetObject is just getObject<BR>
wicket.extensions.model.AbstractCheckBoxModel now has select/ unselect instead of setSelected(Component, boolean), and isSelected doesn't have the Component parameter anymore.</P>

<P>IWrapModel must be used as a return type of the 2 new Model interface markers IAssignementAwareModel and IInheritableModel both of these have a wrapOnXXXX method<BR>
that gives you the component as a parameter. What those method should return is a new model that wraps the outer model (this) and the component it gets in an IWrapModel<BR>
class instance so that it that combination can be used later on to resolve the object in get and set object. See below for an explanation of the 2 special interfaces.</P>

<P>IAssignementAwareModel is used now when the Model implementation needs an Component to resolve things in set/getObject() calls. Because now we don't get the<BR>
component parameter in those 2 methods anymore the component is is &quot;assigned&quot; to that model when we see such a model being assigned to the component an example is ResourceModel<BR>
It wants to do this in the getObject</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> <SPAN class="code-object">Object</SPAN> getObject()
{
   <SPAN class="code-keyword">return</SPAN> Application.get().getResourceSettings().getLocalizer().getString(resourceKey,component, defaultValue);
}</PRE>
</DIV></DIV>
<P>So ResourceModel implements now IComponentAssignedModel<BR>
and then implements</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> IWrapModel wrapOnAssignment(<SPAN class="code-keyword">final</SPAN> Component component)
{
   <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">new</SPAN> AssignmentWrapper(resourceKey, defaultValue, component);
}</PRE>
</DIV></DIV>
<P>That can be an innerclass that has reference to the component and the outer model (which is returned in the getWrappedModel() call of IWrapModel)<BR>
So the above getObject that was in ResourceModel is now moved to the AssignmentWrapper.getObject() method and the getObject() of ResourceModel<BR>
shouldn't be called anymore, so you could throw an exception in that getObject() method.</P>

<P>InheritableModel is the replacement of the ICompoundModel interface it works the same as the ICompoundModel so child components<BR>
do inherit that model from a parent just like the ICompoundModel was inherited. The difference is now that instead of directly assigning the<BR>
ICompoundModel (CompoundPropertyModel) to the component the wrapOnInheritance method is called on thos models, where you should do the same thing<BR>
as with the IComponentAssignedModel so you wrap the component you get and the IInheritableModel  in another model so that model has the component<BR>
to get the property expression from (the id of the component)<BR>
The IInheritableModel differs from the IAssignementAwareModel in the way that the get/setObject calls on the main model itself also should just work.<BR>
Because there you set the main domain/pojo object where all the childs get one property value from.</P>

<P>Looking at the CompoundPropertyModel:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> void setObject(<SPAN class="code-object">Object</SPAN> object)
{
  <SPAN class="code-keyword">this</SPAN>.target = object;
}

<SPAN class="code-keyword">public</SPAN> IWrapModel wrapOnInheritance(Component component)
{
  <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">new</SPAN> AttachedCompoundPropertyModel(component);
}</PRE>
</DIV></DIV>
<P>as you can see the setObject just sets the target == main domain object, so you can do this:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">CompoundPropertyModel model = <SPAN class="code-keyword">new</SPAN> CompoundPropertyModel();
Form form = <SPAN class="code-keyword">new</SPAN> Form(<SPAN class="code-quote">&quot;form&quot;</SPAN>, model);
form.add(<SPAN class="code-keyword">new</SPAN> TextField(<SPAN class="code-quote">&quot;name&quot;</SPAN>));
<SPAN class="code-comment">// later on
</SPAN>model.setObject(<SPAN class="code-keyword">new</SPAN> Person());</PRE>
</DIV></DIV>
<P>Also it wraps the component and the 'this' in an innerclass AttachedCompoundPropertyModel</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">private</SPAN> class AttachedCompoundPropertyModel <SPAN class="code-keyword">extends</SPAN> AbstractPropertyModel <SPAN class="code-keyword">implements</SPAN> IWrapModel,
{
  <SPAN class="code-keyword">private</SPAN> <SPAN class="code-keyword">final</SPAN> Component owner;

  <SPAN class="code-keyword">public</SPAN> AttachedCompoundPropertyModel(Component owner)
  {
    <SPAN class="code-keyword">super</SPAN>(CompoundPropertyModel.<SPAN class="code-keyword">this</SPAN>);
    <SPAN class="code-keyword">this</SPAN>.owner = owner;
  }

  <SPAN class="code-keyword">protected</SPAN> <SPAN class="code-object">String</SPAN> propertyExpression()
  {
    <SPAN class="code-keyword">return</SPAN> CompoundPropertyModel.<SPAN class="code-keyword">this</SPAN>.propertyExpression(owner);
  }

  <SPAN class="code-keyword">public</SPAN> IModel getWrappedModel()
  {
    <SPAN class="code-keyword">return</SPAN> CompoundPropertyModel.<SPAN class="code-keyword">this</SPAN>;
  }</PRE>
</DIV></DIV>
<P>That innerclass extends AbstractPropertyModel in this case and implements IWrapModel<BR>
it overrides the propertyExpression method for the AbstractPropertyModel where it extracts<BR>
the property from the component.<BR>
It also implements getWrappedModel() from IWrapModel to return the outer class instance.</P>

<P>So to summarize if you have implemented your own ICompoundModel that is now the IInheritableModel and you need<BR>
to implement the wrapOnInheritance method.<BR>
If you have an own model that did use the Component parameter of the get/setObject calls you now should implement<BR>
the IComponentAssignedModel and implement the wrapOnAssignment method and move what was in your current<BR>
set/getObject code to that model you return there.</P>

<P>Also the BoundCompoundPropertyModel doesn't have to be used anymore now where you did this before:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">BoundCompoundPropertyModel model = <SPAN class="code-keyword">new</SPAN> BoundCompoundPropertyModel(<SPAN class="code-keyword">new</SPAN> Person());
Form form = <SPAN class="code-keyword">new</SPAN> Form(<SPAN class="code-quote">&quot;form&quot;</SPAN>, model);
TextField textField = <SPAN class="code-keyword">new</SPAN> TextField(<SPAN class="code-quote">&quot;xxx&quot;</SPAN>);
form.add(textField);
model.bind(<SPAN class="code-quote">&quot;name&quot;</SPAN>,textfield);</PRE>
</DIV></DIV>
<P>can be replaced by</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">CompoundPropertyModel model = <SPAN class="code-keyword">new</SPAN> CompoundPropertyModel(<SPAN class="code-keyword">new</SPAN> Person());
Form form = <SPAN class="code-keyword">new</SPAN> Form(<SPAN class="code-quote">&quot;form&quot;</SPAN>, model);
form.add(<SPAN class="code-keyword">new</SPAN> TextField(<SPAN class="code-quote">&quot;xxx&quot;</SPAN>, model.bind(<SPAN class="code-quote">&quot;name&quot;</SPAN>));</PRE>
</DIV></DIV>

<H4><A name="Migrate-1.3-Component.onAttach%2FonBeforeRender%2FonAfterRenderchanges."></A>Component.onAttach/onBeforeRender/onAfterRender changes.</H4>

<P>Before we had this behaviour:</P>

<P>new Page:</P>

<P>Page constructed<BR>
Page.onAttach() &#45;&gt; all the components are visited<BR>
Page.onBeforeRender()<BR>
Page.render &#45;&gt;<BR>
 childComponent.onBeforeRender()<BR>
 childComponent.render()<BR>
 childComponent.onAfterRender()<BR>
Page.onAfterRender()<BR>
Page.onDetach() &#45;&gt; all the components are visited</P>

<P>Listener request which sets a new page:</P>

<P>Page1.componentCalled() &gt;&#45; Page2 is set to response.<BR>
Page2.onAttach() &#45;&gt; all the components are visited<BR>
Page2.onBeforeRender()<BR>
Page2.render &#45;&gt;<BR>
 childComponent.onBeforeRender()<BR>
 childComponent.render()<BR>
 childComponent.onAfterRender()<BR>
Page2.onAfterRender()<BR>
Page2.onDetach() &#45;&gt; all the components are visited<BR>
Page1.onDetach() &#45;&gt; all the components are visited</P>

<P>So the page1 ondetach is called but not the on attach<BR>
in 1.3 on attach is changed so that when a page is used, for an interface call or rendering, onPageAttached is called.<BR>
onBeforeRender did become onAttach because they where pretty much the same already.<BR>
so now the behavior is this:</P>

<P>Page1.onPageAttached() &#45;&gt; this is just called on page. Users can visit components if they need to<BR>
Page1.componentCalled() &gt;&#45; Page2 is set to response.<BR>
Page2.onBeforeRender() &#45;&gt; all the components are visited<BR>
Page2.render()<BR>
Page2.onAfterRender() &#45;&gt; all the components are visited<BR>
Page2.onDetach() &#45;&gt; all the components are visited<BR>
Page1.onDetach() &#45;&gt; all the components are visited</P>

<P>The onAttach method on components is not available any more. <BR>
So everything that was done before this change in onAttach should be done in onBeforeRender<BR>
also in all the 3 call backs we have now (onBeforeRender,onAfterRender and onDetach()) you have<BR>
to make a super.xxx call else you will get an exception.</P>

<H4><A name="Migrate-1.3-Converters"></A>Converters</H4>

<P>IConverter is now more specific to what we're doing in a web environment. The signature is</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> <SPAN class="code-keyword">interface</SPAN> IConverter <SPAN class="code-keyword">extends</SPAN> IClusterable
{
	/**
	 * Converts the given string value to class c.
	 *
	 * @param value
	 *            The string value to convert
	 * @param locale
	 *            The locale used to convert the value
	 * @<SPAN class="code-keyword">return</SPAN> The converted value
	 */
	<SPAN class="code-object">Object</SPAN> convertToObject(<SPAN class="code-object">String</SPAN> value, Locale locale);

	/**
	 * Converts the given value to a string.
	 *
	 * @param value
	 *            The value to convert
	 * @param locale
	 *            The locale used to convert the value
	 *
	 * @<SPAN class="code-keyword">return</SPAN> The converted string value
	 */
	<SPAN class="code-object">String</SPAN> convertToString(<SPAN class="code-object">Object</SPAN> value, Locale locale);
}</PRE>
</DIV></DIV>
<P>The new converters make it much easier to write custom ones. SimpleConverterAdaptor and ITypeConverter are deleted as they are not needed anymore.</P>

<P>Wicket 1.2 had a default Converter implementation that actually served as a registry for converter instances. This is renamed to ConverterLocator and backed by interface IConverterLocator. The application's instance of the converter locator can be configured by overriding Application#newConverterLocator, which is called during startup.</P>

<P>Note that in 1.2.x, the validator was called first, then the converter; this was considered a bug. In 1.3 it's the other way around, so you may need to adjust your code if you do both conversion and validation on the same field.</P>

<H4><A name="Migrate-1.3-ValidationChanges"></A>Validation Changes</H4>

<P>Form component level validation has been decoupled from FormComponent so that validators can be reused outside wicket. The new API can be found in wicket.validation package, with the validator implementations in wicket.validation.validator. From the point of view of validator development not much has changed if you extended the AbstractValidator; if you however implemented the IValidator interface directly you will need to use the new API, namely error reporting via ValidationError instead of FormComponent.error(List,Map). Errors with messages fully constructed inside the validator can still be reported using FormComponent.error(String).</P>

<P>EmailAddressPatternValidator has changed name to EmailAddressValidator. Make sure you update your resource keys appropriately.</P>

<H4><A name="Migrate-1.3-WicketTesterandMockWebApplication"></A>WicketTester and MockWebApplication</H4>

<P>MockWebApplication and WicketTester are no longer derived from WebApplication which allows to use<BR>
&quot;MyApplication&quot; for testing as well instead of copy &amp; paste the MyApps code.</P>

<P>MockWebApplication and therefore WicketTester both consistently use factory methods to create requests and responses now.  This allows for custom request and response subclasses to be used in testing.</P>

<P>Also, it is now possible to use WicketTester with a test framework other than JUnit, by extending BaseWicketTester where all most methods have been moved to.</P>

<H4><A name="Migrate-1.3-Mounts"></A>Mounts</H4>

<P>The path of a mount is now part of the IRequestTargetUrlCodingStrategy (String getMountPath()). See WICKET-410.</P>

<H4><A name="Migrate-1.3-RequestCycle%2CIRequestCycleFactory%2CSession%2CISessionFactory%2CIPageMapandPageMapchanges"></A>RequestCycle, IRequestCycleFactory, Session, ISessionFactory, IPageMap and PageMap changes</H4>

<P>IRequestCycleFactory and ISessionFactory were removed from the code base. You now simply override</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> RequestCycle newRequestCycle(<SPAN class="code-keyword">final</SPAN> Request request, <SPAN class="code-keyword">final</SPAN> Response response)</PRE>
</DIV></DIV>
<P>and</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> Session newSession(Request request, Response response)</PRE>
</DIV></DIV>
<P>in your application to provide a custom request cycle or custom session respectively</P>

<P>RequestCycle's constructor now takes Application as its first parameter instead of Session.</P>

<H4><A name="Migrate-1.3-CustomSessions"></A>Custom Sessions</H4>

<P>Session's constructor signature is now:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">protected</SPAN> Session(Application application, Request request)</PRE>
</DIV></DIV>
<P>The locale is not set right after construction in WebApplication, but rather in the constructor using the passed in request. You can now &quot;fix&quot; the session's locale by setting it in its constructor.</P>

<P>Session.get() now lazily creates Sessions using the Application session factory and RequestCycle methods that work with Sessions now call Session.exists() and/or Session.get() directly.  Finally, IPageMap and PageMap work in the same way and no longer hold a session reference.</P>

<H4><A name="Migrate-1.3-Repeaters"></A>Repeaters</H4>

<P>The repeaters package has moved from wicket-extensions into core. The package name has been changed from wicket.extensions.markup.html.repeater to wicket.markup.repeater. Notice that only DataView and backing classes have moved, the higher level components such as the DataTable are still in wicket-extensions. Also notice that the names of classes have not changed so it should be a simple matter of ctrl-shift-o in your eclipse project to relink to the new classes.</P>

<H4><A name="Migrate-1.3-TextTemplate"></A>TextTemplate</H4>

<P>The TextTemplate package has moved from wicket-extensions into core. The package name has been changed from wicket.extensions.util.resource to org.apache.wicket.util.template.  Notice that the names of classes have not changed so it should be a simple matter of ctrl-shift-o in your eclipse project to relink to the new classes.</P>

<H4><A name="Migrate-1.3-DatePicker"></A>DatePicker</H4>

<P>The DatePicker component has been removed from the wicket-extensions package, as it conflicts with the Apache license.</P>

<P>There are two options for migration:</P>
<UL>
	<LI>A <SPAN class="nobr"><A href="http://wicketstuff.org/confluence/display/STUFFWIKI/wicket-contrib-datepicker" title="Visit page outside Confluence" rel="nofollow">drop-in replacement<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN> (same component) provided by Wicket Stuff.</LI>
	<LI>A new date picker based on the Yahoo UI library, which is available in the wicket-datetime package. Find it under wicket.extensions.yui.calendar.DateField (see also DateTimeField and CalendarPopup for other useful components).</LI>
</UL>


<H4><A name="Migrate-1.3-PortletsJSR168"></A>Portlets JSR-168</H4>

<P><DEL>The portlet support has been moved to wicket-stuff, as we couldn't support it inside the Wicket core. If you need portlet support please checkout the code from wicket-stuff and include that instead. The portlet examples also have been moved to Wicket stuff.</DEL></P>
<UL>
	<LI><DEL><SPAN class="nobr"><A href="http://wicket-stuff.svn.sf.net/svnroot/wicket-stuff/branches/wicket-1.3/wicket-portlets" title="Visit page outside Confluence" rel="nofollow"><DEL>wicket-portlets</DEL><SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN></DEL></LI>
	<LI><DEL><SPAN class="nobr"><A href="http://wicket-stuff.svn.sf.net/svnroot/wicket-stuff/branches/wicket-1.3/wicket-portlet-examples/" title="Visit page outside Confluence" rel="nofollow"><DEL>wicket-portlet-examples</DEL><SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN></DEL></LI>
</UL>



<P>Portlet support has recently been brought back into wicket core and will be available with release 1.3.0-beta4 and supersedes the old Wicket 1.2.x portlet support.<BR>
Detailed information how to use the new portlet support will be provided shortly (stay tuned) but for now check out the umbrella <SPAN class="nobr"><A href="http://issues.apache.org/jira/browse/WICKET-647" title="Visit page outside Confluence" rel="nofollow">WICKET-647<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN> and <SPAN class="nobr"><A href="http://issues.apache.org/jira/browse/WICKET-983" title="Visit page outside Confluence" rel="nofollow">WICKET-983<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN> issues.</P>


<H4><A name="Migrate-1.3-ISessionStore"></A>ISessionStore</H4>

<P>ISessionStore had the following changes:<BR>
 String getSessionId(Request request); &#45;&gt; String getSessionId(Request request, boolean create);<BR>
 + void onBeginRequest(Request request);<BR>
 + void onEndRequest(Request request);<BR>
 + PageMap createPageMap(String name, Session session);<BR>
By default, the creation of lasting sessions is deferred until actually needed. As long no lasting session is yet created and users are accessing stateless pages, a temporary session object is used for the current request.</P>

<P>HttpSessionStore and all subclasses now require the application which they are created for to be passed in in the constructor.</P>

<H4><A name="Migrate-1.3-Button"></A>Button</H4>

<P>AjaxSubmitButton and AjaxSubmitLink now extend Button and Button extends IFormSubmittingComponent. As a result of this, method onSubmit changed from protected to public</P>

<P>The Button component name is a little bit confusing, because it should be used only when the INPUT tag is contained inside a form, otherwise you should use Link:</P>
<UL>
	<LI>when using
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">&lt;input type=<SPAN class="code-quote">&quot;submit&quot;</SPAN>/&gt;</PRE>
</DIV></DIV>
<P> you should use Button.</P></LI>
	<LI>when using
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">&lt;input type=<SPAN class="code-quote">&quot;button&quot;</SPAN>/&gt;</PRE>
</DIV></DIV>
<P> or</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">&lt;button&gt;MyButton&lt;/button&gt;</PRE>
</DIV></DIV>
<P> which are not contained in a form - you should use Link.</P>
<BLOCKQUOTE>
<P>There has been some initiative to rename Button to SubmitButton to<BR>
better reflect what it does. but we didn't want to break the API. We can also<BR>
consider renaming Link to Callback, but that is too abstract.</P></BLOCKQUOTE></LI>
</UL>


<H4><A name="Migrate-1.3-IHeaderContributor"></A>IHeaderContributor</H4>

<P>void IHeaderContributor.renderHead(final Response response); &#45;&gt; void IHeaderContributor.renderHead(final IHeaderResponse response);<BR>
This resulted in a couple of cascading changes, like methods onRenderHeadContribution and onRenderHeadInitContribution not being used anymore. Note that the filtering of duplicate contributions is now part of IHeaderResponse.<BR>
A common fix is this:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">protected</SPAN> void onRenderHeadInitContribution(Response response) {
    writeJsReference(response, AUTOCOMPLETE_JS);
  }</PRE>
</DIV></DIV>
<P>should be converted to:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> void renderHead(IHeaderResponse response) {
    <SPAN class="code-keyword">super</SPAN>.renderHead(response);
    response.renderJavascriptReference(AUTOCOMPLETE_JS);
  }</PRE>
</DIV></DIV>
<P>or for instance code like</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">protected</SPAN> <SPAN class="code-object">String</SPAN> getImplementationId() {
  <SPAN class="code-keyword">return</SPAN> <SPAN class="code-quote">&quot;ArchiveActions&quot;</SPAN>;
}

<SPAN class="code-keyword">protected</SPAN> void onRenderHeadContribution(Response response) {
  <SPAN class="code-keyword">if</SPAN> (!isComplete()) {
    response.write(<SPAN class="code-quote">&quot;&lt;script&gt;&quot;</SPAN>);
    response.write(getCallbackScript().toString());
    response.write(<SPAN class="code-quote">&quot;&lt;/script&gt;&quot;</SPAN>);
  }
}</PRE>
</DIV></DIV>
<P>would be rewritten like</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> void renderHead(IHeaderResponse response) {
  <SPAN class="code-keyword">if</SPAN> (!isComplete()) {
    response.renderJavascript(getCallbackScript(), <SPAN class="code-quote">&quot;ArchiveActions&quot;</SPAN>);
  }
}</PRE>
</DIV></DIV>

<H4><A name="Migrate-1.3-IBehavior"></A>IBehavior</H4>

<P>IBehavior.rendered(Component) &#45;&gt; IBehavior.afterRender(Component)</P>

<P>IBehavior.detachModel(Component) &#45;&gt; IBehavior.detach(Component)</P>

<H4><A name="Migrate-1.3-ReplacementforgetBodyContainer"></A>Replacement for getBodyContainer</H4>

<P>If you had code like this:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> void renderHead(HtmlHeaderContainer container) {
  ((WebPage) getPage()).getBodyContainer().addOnLoadModifier(<SPAN class="code-quote">&quot;foo();&quot;</SPAN>, <SPAN class="code-keyword">null</SPAN>);
  <SPAN class="code-keyword">super</SPAN>.renderHead(container);
}</PRE>
</DIV></DIV>
<P>you should instead let your component implement IHeaderContributor, and then in the interface method, do:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> void renderHead(IHeaderResponse response) {
  response.renderOnLoadJavascript(<SPAN class="code-quote">&quot;foo();&quot;</SPAN>);
}</PRE>
</DIV></DIV>

<H4><A name="Migrate-1.3-FormComponent.IVisitor"></A>FormComponent.IVisitor</H4>

<P>Things have been refactored into interfaces here. If you previously implemented this directly, extend FormComponent.AbstractVisitor instead, and rename your formComponent() implementation to onFormComponent().</P>

<H4><A name="Migrate-1.3-ClientProperties"></A>ClientProperties</H4>

<P>wicket.protocol.http.ClientProperties was taken from the Echo2 project that uses a license which is incompatible with ASL2. It has therefore been rewritten and the usage of it has also changed.</P>

<P>Instead of:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">WebClientInfo clientInfo = (WebClientInfo) Session.get().getClientInfo();
ClientProperties properties = clientInfo.getProperties();

<SPAN class="code-comment">// Before constants where used to get properties
</SPAN><SPAN class="code-object">System</SPAN>.out.println(properties.get(ClientProperties.BROWSER_INTERNET_EXPLORER));</PRE>
</DIV></DIV>
<P>You now say:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">WebClientInfo clientInfo = (WebClientInfo) Session.get().getClientInfo();
ClientProperties properties = clientInfo.getProperties();

<SPAN class="code-comment">// Now you use a property with that name instead
</SPAN><SPAN class="code-object">System</SPAN>.out.println(properties.isBrowserInternetExplorer());</PRE>
</DIV></DIV>

<H4><A name="Migrate-1.3-Applicationsettings"></A>Application settings</H4>

<P>Application#getSettings is now private (so you can't call nor override that anymore), and the getXxxSettings are now overridable in case you want to do fancy stuff like creating a session-dependent settings object. Methods getApplicationPages and getApplicationSettings from component are now removed in favor of the getXxxSettings methods in Application.</P>

<P>Setting get/setDefaultLocale is removed and is does not have a replacement.</P>

<H4><A name="Migrate-1.3-Customresourceloading"></A>Custom resource loading</H4>

<P>In Wicket 1.2 you could override method newMarkupResourceStream from MarkupContainer to provide a custom resource stream for loading the component's markup. The new way of letting markup containers provide custom markup is to let them implement interface IMarkupResourceStreamProvider and implement it's method getMarkupResourceStream. Additionally, a new feature is that you can provide your own markup cache key, which is used in the MarkupCache class. The only real use case for that is to let a markup container return a cache key that is null, in which case the resource won't be cached, causing Wicket to get call getMarkupResourceStream everytime the component's markup is requested. A use case for that is when you have dynamic markup (e.g. from a database) that is request/ session dependent. To achieve this, let your markup container also implement IMarkupCacheKeyProvider and let method getCacheKey return null.</P>

<H4><A name="Migrate-1.3-Treecomponents"></A>Tree components</H4>

<P>The tree components from wicket and wicket-extensions are switched. The one previously in extensions (ajax enabled etc) is now in core and is the recommended component to work with, and the old one is moved to the extensions project. The package names got switched as well.</P>

<H4><A name="Migrate-1.3-Testserializationsettingremoved"></A>Test serialization setting removed</H4>

<P>The setting IDebugSettings#SerializeSessionAttributes is removed. Instead you can use the SecondLevelCacheSessionStore, which serialized (old) pages to a second level cache (user.tmp by default). SecondLevelCacheSessionStore will (probably) be the default configured session store, but you can configure it yourself by doing in your application:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">/**
 * @see wicket.Application#newSessionStore()
 */
<SPAN class="code-keyword">protected</SPAN> ISessionStore newSessionStore() {
  <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">new</SPAN> SecondLevelCacheSessionStore(<SPAN class="code-keyword">new</SPAN> FilePageStore());
}</PRE>
</DIV></DIV>
<P>Also, you can use</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">wicket.util.Objects#checkSerializable(<SPAN class="code-object">Object</SPAN>)</PRE>
</DIV></DIV>
<P>to check for non-serializable objects yourself. You could do this for instance in a custom session store implementation.</P>

<H4><A name="Migrate-1.3-PalettecomponentinwicketextensionsnowhasdefaultCSS."></A>Palette component in wicket-extensions now has default CSS.</H4>

<P>You can revert this back to 1.2.x behaviour by overriding getCSS() and returning null.</P>

<H4><A name="Migrate-1.3-IRequestCycleProcessorgotsimplified"></A>IRequestCycleProcessor got simplified</H4>

<P>The interface itself didn't change, but we've pulled out a redundant layer of indirection that was confusing more than it helped matters. There is now a simply class hierarchy, and WebRequestCycleProcessor is the class you'll most likely need. See for more info the JIRA issue at <SPAN class="nobr"><A href="http://issues.apache.org/jira/browse/WICKET-287" title="Visit page outside Confluence" rel="nofollow">http://issues.apache.org/jira/browse/WICKET-287<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN></P>

<H4><A name="Migrate-1.3-RemovedIPageSettings%23maxPageVersions"></A>Removed IPageSettings#maxPageVersions</H4>

<P>The IPageSettings#maxPageVersions is removed from 1.3. The setting is not relevant for SecondLevelCacheSessionStore (the new default session store implementation), which uses SecondLevelCachePageVersionManager. If you use HttpSessionManager or a custom one together with UndoPageVersionManager, you can provide max page versions number as a UndoPageVersionManager's constructor argument. By default this is now 20 (opposed to max int which it was earlier). See also <SPAN class="nobr"><A href="http://issues.apache.org/jira/browse/WICKET-266" title="Visit page outside Confluence" rel="nofollow">http://issues.apache.org/jira/browse/WICKET-266<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN></P>

<H4><A name="Migrate-1.3-SimplifiedHeaderContributor"></A>Simplified HeaderContributor</H4>

<P>Removed instance methods of HeaderContributor and now just keep one IHeaderContributor instance for clarity and efficiency.</P>

<H4><A name="Migrate-1.3-Removedfeedbackmessagesfrompage"></A>Removed feedback messages from page</H4>

<P>All feedback messages are now maintained by the session. See <SPAN class="nobr"><A href="https://issues.apache.org/jira/browse/WICKET-442" title="Visit page outside Confluence" rel="nofollow">https://issues.apache.org/jira/browse/WICKET-442<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN></P>

<H4><A name="Migrate-1.3-Slightchangeinthehandlingofmultivaluedwidgets"></A>Slight change in the handling of multivalued widgets</H4>

<P>ListMultipleChoice and Palette now call model.setObject() after changing the list elements in updateModel()</P>

<H4><A name="Migrate-1.3-MadeiteasiertoaddIMarkupFiltertoMarkupParser"></A>Made it easier to add IMarkupFilter to MarkupParser</H4>

<P>The MarkupParser can no longer be re-used for multiple markup files. You have to get a new instance from IMarkupParserFactory for every markup file to be parsed (which Wicket-core did already anyway). The MarkupParser API has been changed to make that clear as well.<BR>
This has the advantage that initializing the default set of markup filters now happens in the MarkupParsers constructor and that adding your own filter is now just a matter of invoking appendMarkupFilter() once you created a new MarkupParser. Creating a new MarkupParser happens in MarkupParserFactory (no change) which is registered with Settings (IMarkupSettings). But MarkupParserFactory has changed to reflect the change in MarkupParser. MarkupParserFactory.newMarkupParser(resource) gets you a new MarkupParser. In order add your own IMarkupFilter whenever Wicket requests a parser, you must subclass MarkupParserFactory, substitute newMarkupParser and register your own MarkupParserFactory with Settings.</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java"><SPAN class="code-keyword">public</SPAN> class MyMarkupParserFactory
{
  ...
  <SPAN class="code-keyword">public</SPAN> MarkupParser newMarkupParser(MarkupResouceStream resource)
  {
     MarkupParser parser = <SPAN class="code-keyword">new</SPAN> MarkupParser(resource);
     parser.appendMarkupFilter(<SPAN class="code-keyword">new</SPAN> MyFilter());
     <SPAN class="code-keyword">return</SPAN> parser;
  }
}</PRE>
</DIV></DIV>
<P>In order to allow better control over where in the chain of IMarkupFilter to place your own one, appendMarkupFilter has got a second parameter &quot;markupFilterClass&quot;. Your own IMarkupFilter will inserted before the one identified by the parameter.</P>

<H4><A name="Migrate-1.3-LoggingAPIChange"></A>Logging API Change</H4>

<P>The Logging API changed from Commons Logging to SLF4J, so you need to update your POM in order to use it:<BR>
e.g:<BR>
&#42;if you are using commons-logging:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">&lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-jcl&lt;/artifactId&gt;
     &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;</PRE>
</DIV></DIV>
<P>&#42;if you are using log4j</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">&lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;</PRE>
</DIV></DIV>

<H4><A name="Migrate-1.3-Application%23configure%28%29DEPLOYMENT%2FDEVELOPMENTchanges"></A>Application#configure() DEPLOYMENT/DEVELOPMENT changes</H4>

<P>In 1.2, you should have configured your app for DEPLOYMENT/DEVELOPMENT mode using any of a System property (&quot;wicket.configuration&quot;), a servlet-specific init-param or a servlet context init-param. This will still work exactly as before. You may have previously called Application#configure(String configurationType) to provide your own way of setting this. This previously resulted in #configure() being called twice (one with the system-derived param, and once with your own). This is no longer the case. You can override Application#getConfigurationType() to provide the configuration string, and configure() will be called correctly and only once internally by Wicket. This provides greater flexibility for configuring the default application type settings via Spring or any other mechanism you choose.</P>

<H4><A name="Migrate-1.3-HtmlBodyContainer%3Cbody%3Egone"></A>HtmlBodyContainer &lt;body&gt; gone</H4>

<P>Wicket no longer automatically creates a WebMarkupContainer for &lt;body&gt;, thus &lt;body&gt; is no longer treated any different than any other HTML tag.</P>

<H4><A name="Migrate-1.3-PasswordTextFieldnolongersupportscookiesbydefault"></A>PasswordTextField no longer supports cookies by default</H4>

<P>Calling <TT>setPersistent(true)</TT> on a PasswordTextField will now yield an exception (<TT>FormComponent PasswordTextField does not support cookies</TT>) due to security issues. Overload the method <TT>supportsPersistence</TT> to get the old behavior:</P>
<DIV class="code"><DIV class="codeContent">
<PRE class="code-java">add(password = <SPAN class="code-keyword">new</SPAN> PasswordTextField(<SPAN class="code-quote">&quot;password&quot;</SPAN>, <SPAN class="code-keyword">new</SPAN> PropertyModel(properties, <SPAN class="code-quote">&quot;password&quot;</SPAN>)) {
    <SPAN class="code-keyword">protected</SPAN> <SPAN class="code-object">boolean</SPAN> supportsPersistence() {
        <SPAN class="code-keyword">return</SPAN> <SPAN class="code-keyword">true</SPAN>;
    }
});</PRE>
</DIV></DIV>

<H3><A name="Migrate-1.3-NewFeatures"></A>New Features</H3>


<H4><A name="Migrate-1.3-wicket%3Aenclosuretag"></A>wicket:enclosure tag</H4>

<P>see <SPAN class="nobr"><A href="http://www.nabble.com/two-small-feature-ideas-tf2107229.html#a5835972" title="Visit page outside Confluence" rel="nofollow">http://www.nabble.com/two-small-feature-ideas-tf2107229.html#a5835972<SUP><IMG class="rendericon" src="http://cwiki.apache.org/confluence/images/icons/linkext7.gif" height="7" width="7" align="absmiddle" alt="" border="0"></SUP></A></SPAN></P>

<H4><A name="Migrate-1.3-Reloadingclassloader"></A>Reloading class loader</H4>

<P>see ReloadingClassLoader</P>

<H4><A name="Migrate-1.3-RelativeURLs"></A>Relative URLs</H4>

<P>Wicket now generates all its URLs as relative paths, which means it works with zero-config behind a proxy server.</P>

<P>ApplicationSettings.get/setContextPath() is therefore no longer required or available.</P>

<P>The contextPath servlet init parameter that configured this in 1.2.x is therefore also no longer required/honoured.</P>

<P>If you were previously using PrependContextPathHandler, this has been removed and is no longer required (relative path prepending is included by default for all your markup).</P>
        </DIV>

        
      </DIV>
    </DIV>
  </BODY>
</HTML>
