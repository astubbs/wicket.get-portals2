/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package wicket.markup.html.image;

import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.util.LinkedList;
import java.util.List;

import wicket.Component;
import wicket.MarkupContainer;
import wicket.Resource;
import wicket.WicketRuntimeException;
import wicket.markup.ComponentTag;
import wicket.markup.html.image.resource.RenderedDynamicImageResource;
import wicket.model.IAssignmentAwareModel;
import wicket.model.IInheritableModel;
import wicket.model.IModel;
import wicket.model.IWrapModel;
import wicket.util.string.Strings;

/**
 * Renders its model text into a PNG, using any typeface available to the JVM.
 * The size of the image is determined by the model text and the characteristics
 * of font selected. The default font is 14pt sans, plain black on a white
 * background. Background may be set to null for alpha transparency, depending
 * on browser support. The image's alt attribute will be set to the model text,
 * and width and height attributes will be set appropriately.
 * <p>
 * This class is inspired by, and draws code from, Wicket's
 * DefaultButtonImageResource.
 * </p>
 * 
 * @author Nathan Hamblen
 * @see wicket.markup.html.image.resource.DefaultButtonImageResource
 */
public class RenderedLabel extends Image
{
	/**
	 * Inner class that renders the model text into an image resource.
	 * 
	 * @see wicket.markup.html.image.resource.DefaultButtonImageResource
	 */
	protected class RenderedTextImageResource extends RenderedDynamicImageResource
	{
		private static final long serialVersionUID = 1L;

		protected RenderedTextImageResource()
		{
			super(1, 1, "png"); // tiny default that will resize to fit text
			setType(BufferedImage.TYPE_INT_ARGB); // allow alpha transparency
		}

		/**
		 * Called when the correct size of this resource is needed before its
		 * data.
		 */
		public void determineSize()
		{
			render();
		}

		/**
		 * Breaks source string into lines no longer than this label's maxWidth,
		 * if not null.
		 * 
		 * @param source
		 *            this label's model, previously retrieved
		 * @param metrics
		 *            metrics for the font we will use for display
		 * @param outputLines
		 *            list to receive lines generated by this function
		 * @return length in pixels of the longest line
		 */
		protected int breakLines(String source, FontMetrics metrics, List<String> outputLines)
		{
			if (maxWidth == null)
			{
				outputLines.add(source);
				return metrics.stringWidth(source);
			}
			String sp = " ";
			String words[] = source.split(sp);
			StringBuilder line = new StringBuilder();
			int topWidth = 0;
			for (String word : words)
			{
				if (line.length() > 0)
				{
					int curWidth = metrics.stringWidth(line + sp + word);
					if (curWidth > maxWidth)
					{
						outputLines.add(line.toString());
						line.setLength(0);
					}
					else
						line.append(sp);
				}
				line.append(word);
				topWidth = Math.max(metrics.stringWidth(line.toString()), topWidth);
			}
			outputLines.add(line.toString());
			return topWidth;
		}

		/** Renders text into image. */
		protected boolean render(final Graphics2D graphics)
		{
			renderedText = getModelObjectAsString(); // get text from outer
			// class model
			final int width = getWidth(), height = getHeight();

			// draw background if not null, otherwise leave transparent
			if (backgroundColor != null)
			{
				graphics.setColor(backgroundColor);
				graphics.fillRect(0, 0, width, height);
			}

			// render as a 1x1 pixel if text is empty
			if (renderedText == null)
			{
				if (width == 1 && height == 1)
					return true;
				setWidth(1);
				setHeight(1);
				return false;
			}

			// Get size of text
			graphics.setFont(font);
			final FontMetrics metrics = graphics.getFontMetrics();

			List<String> lines = new LinkedList<String>();

			int dxText = breakLines(renderedText, metrics, lines), lineHeight = metrics.getHeight(), dyText = lineHeight
					* lines.size();

			// resize and redraw if we need to
			if (dxText != width || dyText != height)
			{
				setWidth(dxText);
				setHeight(dyText);
				return false;
			}

			// Turn on anti-aliasing
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
					RenderingHints.VALUE_ANTIALIAS_ON);

			graphics.setColor(color);

			// Draw each line at its baseline
			int baseline = metrics.getAscent();
			for (String line : lines)
			{
				graphics.drawString(line, 0, baseline);
				baseline += lineHeight;
			}
			return true;
		}
	}

	private static final long serialVersionUID = 1L;

	/**
	 * Utility method for creating Font objects from resources.
	 * 
	 * @param fontRes
	 *            Resource containing a TrueType font descriptor.
	 * @return Plain, 16pt font derived from the resource.
	 */
	public static Font fontForResource(Resource fontRes)
	{
		try
		{
			InputStream is = fontRes.getResourceStream().getInputStream();
			Font font = Font.createFont(Font.TRUETYPE_FONT, is);
			is.close();
			return font.deriveFont(Font.PLAIN, 16);
		}
		catch (Throwable e)
		{
			throw new WicketRuntimeException("Error loading font resources", e);
		}
	}

	private Color backgroundColor = Color.WHITE;

	private Color color = Color.BLACK;

	private Font font = new Font("sans", Font.PLAIN, 14);

	private Integer maxWidth;

	private String renderedText;

	private RenderedTextImageResource resource;

	/**
	 * Constructor to be used if model is derived from a compound property
	 * model. The model object <b>must</b> be a string.
	 * 
	 * @param parent
	 * @param id
	 */
	public RenderedLabel(MarkupContainer parent, String id)
	{
		super(parent, id);
		setImageResource(resource = new RenderedTextImageResource());
		setEscapeModelStrings(false);
	}

	/**
	 * Constructor with explicit model. The model object <b>must</b> be a
	 * string.
	 * 
	 * @param parent
	 * @param id
	 *            Wicket id
	 * @param model
	 */
	public RenderedLabel(MarkupContainer parent, String id, IModel model)
	{
		super(parent, id, model);
		setImageResource(resource = new RenderedTextImageResource());
		setEscapeModelStrings(false);
	}

	/**
	 * @return current background color
	 */
	public Color getBackgroundColor()
	{
		return backgroundColor;
	}

	/**
	 * @return current text color
	 */
	public Color getColor()
	{
		return color;
	}

	/**
	 * @return current text font
	 */
	public Font getFont()
	{
		return font;
	}

	/**
	 * @return maximum width in pixels
	 */
	public Integer getMaxWidth()
	{
		return maxWidth;
	}

	/**
	 * Specify a background color to match the page. Specify null for a
	 * transparent background blended with the alpha channel, causing IE6 to
	 * display a gray background.
	 * 
	 * @param backgroundColor
	 *            color or null for transparent
	 * @return this for chaining
	 */
	public RenderedLabel setBackgroundColor(Color backgroundColor)
	{
		this.backgroundColor = backgroundColor;
		resource.invalidate();
		return this;
	}

	/**
	 * @param color
	 *            Color to print text
	 * @return this, for chaining
	 */
	public RenderedLabel setColor(Color color)
	{
		this.color = color;
		resource.invalidate();
		return this;
	}

	/**
	 * @param font
	 *            text font
	 * @return this, for chaining
	 */
	public RenderedLabel setFont(Font font)
	{
		this.font = font;
		resource.invalidate();
		return this;
	}

	/**
	 * Specify a maximum pixel width, causing longer renderings to wrap.
	 * 
	 * @param maxWidth
	 *            maximum width in pixels
	 * @return this, for chaining
	 */
	public RenderedLabel setMaxWidth(Integer maxWidth)
	{
		this.maxWidth = maxWidth;
		resource.invalidate();
		return this;
	}


	/**
	 * Restores compound model resolution that is disabled in the Image
	 * superclass.
	 */
	@SuppressWarnings("unchecked")
	@Override
	protected IModel initModel()
	{
		// Search parents for CompoundPropertyModel
		for (Component current = getParent(); current != null; current = current.getParent())
		{
			// Get model
			IModel model = current.getModel();

			if (model instanceof IWrapModel)
			{
				model = ((IWrapModel)model).getNestedModel();
			}

			if (model instanceof IInheritableModel)
			{
				// we turn off versioning as we share the model with another
				// component that is the owner of the model (that component
				// has to decide whether to version or not
				setVersioned(false);

				// return the shared inherited
				model = ((IInheritableModel)model).wrapOnInheritance(this);
				if (model != null && (model instanceof IAssignmentAwareModel))
				{
					model = ((IAssignmentAwareModel)model).wrapOnAssignment(this);
				}

				return model;
			}
		}

		// No model for this component!
		return null;
	}

	@Override
	protected void onBeforeRender()
	{
		if (!Strings.isEqual(renderedText, getModelObjectAsString()))
			resource.invalidate();
	}

	/**
	 * Adds image-specific attributes including width, height, and alternate
	 * text. A hash is appended to the source URL to trigger a reload whenever
	 * drawing attributes change.
	 */
	@Override
	protected void onComponentTag(ComponentTag tag)
	{
		super.onComponentTag(tag);

		String text = getModelObjectAsString();
		if (text != null)
		{
			int hash = text.hashCode() ^ font.hashCode() ^ color.hashCode();
			if (backgroundColor != null)
				hash ^= backgroundColor.hashCode();
			if (maxWidth != null)
				hash ^= maxWidth.hashCode();

			String url = tag.getAttributes().getString("src");
			url = url + ((url.indexOf("?") >= 0) ? "&" : "?");
			url = url + "wicket:antiCache=" + hash;

			tag.put("src", url);
		}

		resource.determineSize();
		tag.put("width", resource.getWidth());
		tag.put("height", resource.getHeight());

		tag.put("alt", text);
	}
}